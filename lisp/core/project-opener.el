;;; project-opener.el --- 

;; Copyright (C) 2018  Ernesto Alfonso <erjoalgo@gmail.com>

;; Author: Ernesto Alfonso <erjoalgo@gmail.com>
;; Keywords: lisp
;; Created: 07 Oct 2018

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

(defun add-one-time-hook (hook-var fn)
  (let ((fun-sym (gensym "anon-hook-fn")))
    ;; (lexical-let ((fn fn) (fun-sym fun-sym))
    (fset fun-sym
          `(lambda (&rest args)
             "autogenerated, self-destroying hook"
             (safe-funcall ,fn args)
             (remove-hook ',hook-var ',fun-sym)))
    ;; some functions, like remove hook, need the symbol-value
    (set fun-sym (symbol-function fun-sym))
    (add-hook hook-var fun-sym)))

(defun add-one-time-log-hooks (hook-syms)
  (interactive
   (list (symbols-matching-regexp
          (read-string "enter hook symbol regexp: " "-hook"))))
  (loop for hook in hook-syms do
        (add-one-time-hook
         hook
         `(lambda (&rest args)
            (message "%s invoked with args %s on directory %s"
                     ',hook args default-directory)))))

(defun symbols-matching-regexp (regexp)
  (save-match-data
    (let (syms)
      (mapatoms (lambda (atom) (when (and (symbolp atom)
                                          (string-match regexp (symbol-name atom)))
                                 (push atom syms))))
      syms)))


;; '(add-one-time-hook ' post-command-hook
;;                             (lambda () (message "one-time-hook ran")))

(defun find-files-recursively (top &optional pred)
  (assert (f-absolute? top))
  ;; (lexical-let ((default-directory (f-expand top)))
  (dolist (file (directory-files top))
    (let ((abs (f-join top file)))
      (cond
       ((f-file? abs) (when (or (null pred)
                                (funcall pred abs))
                        (find-file-noselect abs)))
       ((f-directory? abs) (unless (member file '(".." "." ".git"))
                             (find-files-recursively abs)))
       ((f-symlink? abs) (warn "broken symlink: %s" abs))
       (t (require 'edebug) (edebug)
          (error "not a file or directory? %s" abs))))))

(defun project-open-default-matcher (top-level-directory &rest ...)
  (find-files-recursively top-level-directory))

(defvar project-open-matchers-list nil
  "List of project matchers.
   Each matcher is invoked with the project's top-level-directory
   and a list of top-level files/directories.")

(defun project-open-cl (top-level-directory &optional top-level-files)
  "project-opener matcher for a CL project rooted at
   TOP-LEVEL-DIRECTORY.
   Start slime, load the .asd file,
   quickload all the systems defined in it.
   Also load a file 'repl-startup.lisp' if it exists."

  (loop for file in top-level-files thereis
       (when (equal "asd" (f-ext file))
         (let ((default-directory top-level-directory))
           (save-excursion
             (goto-char (point-min))
             (cl-labels
                 ((read-top-level-sexps (string)
                                        (read (format "(%s)" string)))
                  (read-file-defs-matching
                   (filename def-syms)
                   (with-temporary-current-file
                       filename
                     (loop for sexp in (read-top-level-sexps (buffer-string))
                        when (and (consp sexp) (member (car sexp) def-syms))
                        collect (cadr sexp)))))
               (let* ((asd-filename file)
                      (packages-filename "packages.lisp")
                      (lisp-startup-file "repl-startup.lisp")
                      (systems
                       (read-file-defs-matching asd-filename '(defsystem asdf:defsystem)))
                      (packages
                       (when (file-exists-p packages-filename)
                         (read-file-defs-matching packages-filename '(defpackage asdf:defpackage))))
                      (sexp `(CL:progn
                              (CL:load ,asd-filename)
                              ,@(loop for system in systems collect
                                      `(ql:quickload ',system))))
                      (set-package-sexp
                       (when packages
                         `((slime-repl-set-package
                            ,(upcase (symbol-name (car packages))))))))
                 (message "pacakges %s" packages)
                 (message "pacakges %s" set-package-sexp)
                 (message "systems %s" systems)
                 (message "dir %s" default-directory)
                 (add-one-time-hook
                  ;; ' slime-connected-hook
                  ' slime-editing-mode-hook
                  `(lambda (&rest args)
                     (message "on slime hook. current buff %s %s %s %s"
                              (current-buffer) major-mode
                              default-directory
                              ,top-level-directory)
                     (message "sexp: %s" ',sexp)
                     (slime-change-directory ,top-level-directory)
                     (slime-cd ,top-level-directory)
                     (slime-eval ',sexp)
                     ,@set-package-sexp
                     (when (file-exists-p ,lisp-startup-file)
                       (slime-eval '(CL:LOAD ,lisp-startup-file)))))
                 (message "dir %s" default-directory)
                 (slime))))
           (find-files-recursively top-level-directory
                                   (lambda (filename)
                                     (not (equal "fasl"
                                                 (f-ext filename)))))
           t))))
(add-to-list 'project-open-matchers-list 'project-open-cl)

(defun project-open (top-level-directory)
  (interactive (list (read-directory-name "enter project directory: "
                                          "~/git/")))
  (loop for matcher in (append project-open-matchers-list
                               (list 'project-open-default-matcher))
     with top-level-filenames = (directory-files top-level-directory)
     thereis (funcall matcher top-level-directory
                      top-level-filenames)))

(provide 'project-opener)
;;; project-opener.el ends here
